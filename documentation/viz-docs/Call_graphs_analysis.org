* Generating Call Graphs
** What you need
A rooted phone

Python (2.7.x)

graphviz (sudo apt-get install graphviz / pacman -S graphviz / use your favorite package manager).

python graphviz library (https://pypi.python.org/pypi/graphviz)

Note: You do not need binderfilter on your device to generate sequence diagrams or call graphs. All you need is a rooted phone.

** What it does
Our aim with visualizing binder calls was to present the live picture of how data flows through the
Android application ecosystem. Note that we present binder transactions as they occur and not notification
messages also communicated through binder (such as buffer_release, death notifications, etc) since binder
transactions are the vehicle for passing information between processes.

Sequence diagrams can be used to analyse the interaction between two processes of interest.
Interesting interactions can be captured and analysed to greater granularity with the help of the
binderfilter kernel module.
  
** How it works - Sequence Diagrams
python visualize.py -s <process 1 name> <process 2 name>

Example:
python visualize.py -s com.facebook.katana system_server

*** How would you find out the right process names
python visualize.py -v 

Look at the abstract graph generated, the nodes are labelled with process names
taking part in binder IPC [If you do not find your desired process here try opening
it while the graph is being generated].

** How it works - Binder IPC Call graph
python visualize.py -v abstract [this is the default mode]
python visualize.py -v true ['real' mode]

When we map all the edges between all the nodes in the binder call graph, the graph can look a bit messy
and sometimes it may make more sense to get a better overall picture of the call graph.

The difference between abstract mode and real mode is that edges of the same transaction type 
between any two nodes are only displayed once in 'abstract' mode while 'real' mode has information
on all the transactions.

*** Color Coding

Solid white arrows - BC_TRANSACTION

Dotted White arrows - BC_REPLY

Solid cyan arrows - BR_TRANSACTION

Dotted cyan arrows - BR_REPLY

** Why It works

Both IPC call graphs and Sequence diagrams are generated by combining logs generated from two sources:
 Filtering for the right entries from : dmesg -n 7 and
 using /sys/kernel/debug/binder/transaction_log to resolve one way calls [described later]

These are the binder transaction types:

BC_TRANSACTION - Client binder(implementing the IBinder interface) writes to /dev/binder and waits for a response (suspending itself) if the 
transaction is not one way. If the transaction is one way then the binder does not wait.


BR_TRANSACTION - A binder worker thread (associated with /dev/binder) receives the transaction from the client binder, strips sender information IF one way
and forwards it to the service Binder thread. 

BC_REPLY - Service sends the reply to /dev/binder.

BR_REPLY - Binder forwards the reply to the client. This can also be one way in the case where the service sends an unsolicited message to the client.
In this case the client does not know who the message came from, but receives it anyway.

The sequence diagram of a two way transaction should look like this:

#+BEGIN_CENTER


| P1               | /dev/binder      | P2        |
|------------------+------------------+-----------|
| BC_TRANSACTION > |                  |           |
|                  |                  |           |
|                  | BR_TRANSACTION > |           |
|                  |                  |           |
|                  |                  | <BC_REPLY |
|                  |                  |           |
| < BR_REPLY       |                  |           |

#+END_CENTER

*** Hooking the right logs
How are we sure we caught all the transactions that go through binder ?
By looking at the code of course.
Here is a step through of binder.c at :

https://github.com/torvalds/linux/blob/ae75d1aefe04c30de9b344abc69939cf7b537ac6/drivers/android/binder.c

#+BEGIN_SRC

Method binder_ioctl (Line 3243) is called every time a process makes an IPC call through /dev/binder.
.switch(cmd) on the command passed to the binder drive (Line 3267)

..We are only interested in BINDER_WRITE_READ (the others are bookkeeping commands)

...binder_ioctl_write_read (Line 3269)	  

|--------------------------------------------|
read_size > 0  (Line 3175)          write_size > 0 (Line 3162)  			  
(BR_TRANSACTION,BR_REPLY)          (BC_TRANSACTION, BC_REPLY)
         /                                          \
binder_thread_read (Line 2654)              binder_thread_write (Line 2252)                                         
     |                                                |
     |                                                |
binder_debug -- print details          binder_transaction method called (Line 2451) 
(Line 2937)                                                          \
								      binder_debug 
								      print details (Line 1975)

#+END_SRC

The actual logs that we parse and create sequence diagrams come from the output of 
dmesg -n 7 (log level 7).

*** Resolving one way calls
There is one small problem though:
Some binder transactions are one way. 

**** How Binder knows a transaction is one way
Transactions are set as one way by the calling process by setting a certain flag FLAG_ONEWAY in the binder interfact of the application.

See the IBinder doc at https://developer.android.com/reference/android/os/IBinder.html describing
-----
int	FLAG_ONEWAY
Flag to transact(int, Parcel, Parcel, int): this is a one-way call, meaning that the caller returns immediately, without waiting for a result from the callee.
-----
Check :
https://android.googlesource.com/platform/frameworks/native/+/bd558d61871218f5b13df2fe4b7cc3b530ee947c/include/binder/IBinder.h
Line 47:
#+BEGIN_SRC C
enum {
        FIRST_CALL_TRANSACTION  = 0x00000001,
        LAST_CALL_TRANSACTION   = 0x00ffffff,
        PING_TRANSACTION        = B_PACK_CHARS('_','P','N','G'),
        DUMP_TRANSACTION        = B_PACK_CHARS('_','D','M','P'),
        INTERFACE_TRANSACTION   = B_PACK_CHARS('_', 'N', 'T', 'F'),
        SYSPROPS_TRANSACTION    = B_PACK_CHARS('_', 'S', 'P', 'R'),
        // Corresponds to TF_ONE_WAY -- an asynchronous call.
        FLAG_ONEWAY             = 0x00000001 
};
#+END_SRC
-----

Note the reference to TF_ONE_WAY . This is defined in
https://github.com/torvalds/linux/blob/master/include/uapi/linux/android/binder.h
#+BEGIN_SRC
enum transaction_flags {
	TF_ONE_WAY	= 0x01,	/* this is a one-way call: async, no return */
	TF_ROOT_OBJECT	= 0x04,	/* contents are the component's root object */
	TF_STATUS_CODE	= 0x08,	/* contents are a 32-bit status code */
	TF_ACCEPT_FDS	= 0x10,	/* allow replies with file descriptors */
};
#+END_SRC C
This flag is checked whenever Binder receives a new transaction.

**** Binder's obfuscation

See line 1994:1997 in https://github.com/torvalds/linux/blob/ae75d1aefe04c30de9b344abc69939cf7b537ac6/drivers/android/binder.c
#+BEGIN_SRC C
if (!reply && !(tr->flags & TF_ONE_WAY))
    t->from = thread;
else
    t->from = NULL;
#+END_SRC
Here t is a variable of type binder_transaction defined in the file on line 343.
What Binder did was that it removed all information about the client (t->from set to NULL) before forwarding the message to the service.
We imagine this is to ensure that one way calls remain one way and that there is no way to reply to the client.

As we saw previously , line 2937 in binder.c (https://github.com/torvalds/linux/blob/ae75d1aefe04c30de9b344abc69939cf7b537ac6/drivers/android/binder.c)
#+BEGIN_SRC C
binder_debug(
    BINDER_DEBUG_TRANSACTION,
    "%d:%d %s %d %d:%d, cmd %d size %zd-%zd ptr %016llx-%016llx\n",
    proc->pid, thread->pid,
    (cmd == BR_TRANSACTION) ? "BR_TRANSACTION" :
    "BR_REPLY",
    t->debug_id, t->from ? t->from->proc->pid : 0,
    t->from ? t->from->pid : 0, cmd,                       // Binder logs show pid to be zero if there is no information on the sender.
    t->buffer->data_size, t->buffer->offsets_size,
    (u64)tr.data.ptr.buffer, (u64)tr.data.ptr.offsets
); 
#+END_SRC
is the line that prints BR_TRANSACTION/BR_REPLY logs.

Losing information about the sender of one way calls may be convenient for binder policy but is inconvenient if we want to get an overall
picture of the system.
-----
** Enter /sys/kernel/debug/binder/transaction_log !

When we read /sys/kernel/debug/binder/transaction_log the logs look something like this :

30319178: reply from 437:579 to 959:980 node 0 handle -1 size 0:0

30319179: async from 959:980 to 437:0 node 2955 handle 6 size 80:0

30319180: async from 1339:1339 to 437:0 node 5854 handle 39 size 80:0

30319181: call  from 959:980 to 437:0 node 14 handle 1 size 1056:80

30319182: reply from 437:445 to 959:980 node 0 handle -1 size 0:0

30319183: async from 1339:1339 to 437:0 node 5854 handle 39 size 80:0

30319184: async from 1339:1339 to 437:0 node 5854 handle 39 size 80:0

30319185: async from 437:500 to 959:0 node 993 handle 2 size 68:0

30319189: async from 1339:1339 to 437:0 node 5854 handle 39 size 80:0

30319190: async from 1339:1339 to 437:0 node 5854 handle 39 size 80:0

30319191: async from 437:498 to 959:0 node 993 handle 2 size 68:0

30319192: async from 1859:1859 to 437:0 node 17327 handle 18 size 80:0

30319193: async from 437:499 to 959:0 node 993 handle 2 size 68:0

30319194: call  from 1859:1963 to 437:0 node 30318980 handle 8 size 96:0

30319195: reply from 437:447 to 1859:1963 node 0 handle -1 size 24:0

30319196: call  from 1859:1963 to 437:0 node 30318980 handle 8 size 84:0

The relevant code that prints the above is binder.c:3614,
#+BEGIN_SRC C
static void print_binder_transaction_log_entry(struct seq_file *m,
					struct binder_transaction_log_entry *e)
{
	seq_printf(m,
		   "%d: %s from %d:%d to %d:%d node %d handle %d size %d:%d\n",
		   e->debug_id, (e->call_type == 2) ? "reply" :
		   ((e->call_type == 1) ? "async" : "call "), e->from_proc,
		   e->from_thread, e->to_proc, e->to_thread, e->to_node,
		   e->target_handle, e->data_size, e->offsets_size);
}
#+END_SRC
where the linked list binder_transaction_log_entry is populated from :
#+BEGIN_SRC C
binder_transaction(
    struct binder_proc *proc,
    struct binder_thread *thread,
    struct binder_transaction_data *tr, int reply,
    binder_size_t extra_buffers_size
) {
...
e = binder_transaction_log_add(&binder_transaction_log); // Line 1850
...
} 
#+END_SRC
in binder.c https://github.com/torvalds/linux/blob/ae75d1aefe04c30de9b344abc69939cf7b537ac6/drivers/android/binder.c

Note that this entry is added before line 1994 in the same function where 'from' information is erased.

Combining this log (say a 'table') with the log with no sender info (another 'table') and taking the property
'debug_id' of the binder transaction as the primary key gives us full binder information for one way calls.

There is a minor inconvenience however, /sys/kernel/debug/binder/transaction_log has a fixed length and is refreshed
every time there is a new transaction, which means it is refreshed very often. Sometimes, there may be one way calls that
are unresolved. They are bundled under the node name 'async RPC' in the call graph. 
